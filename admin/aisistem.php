<?php
ob_start(); // Buffer output to prevent whitespace issues
require_once __DIR__ . '/auth.php';
require_once __DIR__ . '/../settings.php';
require_once __DIR__ . '/db.php';

// Clear any output generated by included files (like BOM or whitespace)
ob_clean();

// JSON Output & Error Suppression
error_reporting(E_ALL); // Hata ayıklama için geçici olarak açalım, loglara düşsün
ini_set('display_errors', 0); // Ekrana basmasın, JSON bozulur
header('Content-Type: application/json; charset=utf-8');

// Timeout & Memory Settings
set_time_limit(300); // 5 dakika
ini_set('memory_limit', '512M');

// Sadece adminler
if (!$is_admin) {
    http_response_code(403);
    echo json_encode(['status' => 'error', 'message' => 'Yetkisiz erişim.']);
    exit;
}

// Veritabanı Tablolarını Kontrol Et / Oluştur
$driver = $db->getAttribute(PDO::ATTR_DRIVER_NAME);
$is_sqlite = ($driver === 'sqlite');

try {
    if ($is_sqlite) {
        $db->exec("
            CREATE TABLE IF NOT EXISTS ai_settings (
                key_name TEXT PRIMARY KEY,
                value_text TEXT
            );
            CREATE TABLE IF NOT EXISTS ai_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                action_type TEXT,
                prompt TEXT,
                response TEXT,
                file_path TEXT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            );
        ");
    } else {
        $db->exec("
            CREATE TABLE IF NOT EXISTS ai_settings (
                key_name VARCHAR(255) PRIMARY KEY,
                value_text LONGTEXT
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
            
            CREATE TABLE IF NOT EXISTS ai_logs (
                id INT AUTO_INCREMENT PRIMARY KEY,
                user_id INT,
                action_type VARCHAR(50),
                prompt LONGTEXT,
                response LONGTEXT,
                file_path VARCHAR(255),
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
        ");
    }
} catch (Exception $e) {
    // Tablo zaten varsa veya hata oluşursa devam et (silent)
}

// İşlemler
$jsonInput = json_decode(file_get_contents('php://input'), true) ?? [];
$action = $_POST['action'] ?? ($_GET['action'] ?? ($jsonInput['action'] ?? ''));

if (!$action) {
    echo json_encode(['status' => 'error', 'message' => 'Geçersiz istek: Action parametresi eksik.']);
    exit;
}

if ($action === 'get_settings') {
    $stmt = $db->query("SELECT * FROM ai_settings");
    $settings = $stmt->fetchAll(PDO::FETCH_KEY_PAIR);

    // Varsayılan modeller
    $defaultModels = [
        ['id' => 'google/gemini-2.5-flash-lite-preview-09-2025', 'name' => 'Google Gemini 2.5 Flash Lite (Preview)', 'free' => false],
        ['id' => 'google/gemini-2.0-flash-exp:free', 'name' => 'Gemini 2.0 Flash (Ücretsiz)', 'free' => true],
        ['id' => 'meta-llama/llama-3.2-3b-instruct:free', 'name' => 'Llama 3.2 3B (Meta - Ücretsiz)', 'free' => true],
        ['id' => 'mistralai/pixtral-12b:free', 'name' => 'Pixtral 12B (Ücretsiz)', 'free' => true],
        ['id' => 'qwen/qwen-2-7b-instruct:free', 'name' => 'Qwen 2 7B (Ücretsiz)', 'free' => true],
        ['id' => 'openai/gpt-4o-mini', 'name' => 'OpenAI GPT‑4o‑mini', 'free' => false],
        ['id' => 'openai/gpt-4o', 'name' => 'OpenAI GPT‑4o', 'free' => false],
        ['id' => 'anthropic/claude-3.5-sonnet', 'name' => 'Claude 3.5 Sonnet', 'free' => false],
    ];

    // Kayıtlı özel modelleri getir
    $customModels = [];
    if (!empty($settings['custom_models'])) {
        $customModels = json_decode($settings['custom_models'], true) ?? [];
    }

    // Birleştir (Kullanıcı modelleri öncelikli olsun isterseniz array_merge sırasını değiştirebilirsiniz)
    $allModels = array_merge($defaultModels, $customModels);

    echo json_encode([
        'status' => 'success',
        'api_key' => $settings['api_key'] ?? '',
        'api_url' => $settings['api_url'] ?? 'https://openrouter.ai/api/v1',
        'selected_model' => $settings['selected_model'] ?? 'google/gemini-2.0-flash-exp:free',
        'system_models' => $allModels,
        'custom_models_raw' => $customModels // Frontend yönetimi için ham veri
    ]);
    exit;
}

// Model Ekle / Sil / Token Ayarı
if ($action === 'save_models') {
    $models = $_POST['models'] ?? ''; // JSON string olarak gelecek

    // Basit doğrulama yapılabilir
    if ($models) {
        $stmt = $db->prepare("REPLACE INTO ai_settings (key_name, value_text) VALUES ('custom_models', ?)");
        $stmt->execute([$models]);
    }

    echo json_encode(['status' => 'success', 'message' => 'Model listesi güncellendi.']);
    exit;
}

if ($action === 'save_settings') {
    $apiKey = $_POST['api_key'] ?? '';
    $apiUrl = $_POST['api_url'] ?? '';
    $model = $_POST['model'] ?? '';

    if ($apiKey) {
        $stmt = $db->prepare("REPLACE INTO ai_settings (key_name, value_text) VALUES ('api_key', ?)");
        $stmt->execute([$apiKey]);
    }

    if ($apiUrl) {
        $stmt = $db->prepare("REPLACE INTO ai_settings (key_name, value_text) VALUES ('api_url', ?)");
        $stmt->execute([$apiUrl]);
    }

    if ($model) {
        $stmt = $db->prepare("REPLACE INTO ai_settings (key_name, value_text) VALUES ('selected_model', ?)");
        $stmt->execute([$model]);
    }

    echo json_encode(['status' => 'success', 'message' => 'Ayarlar kaydedildi.']);
    exit;
}

if ($action === 'chat') {
    $stmt = $db->query("SELECT value_text FROM ai_settings WHERE key_name = 'api_key'");
    $apiKey = $stmt->fetchColumn();

    $stmt2 = $db->query("SELECT value_text FROM ai_settings WHERE key_name = 'api_url'");
    $dbApiUrl = $stmt2->fetchColumn();
    $baseUrl = $dbApiUrl ? $dbApiUrl : 'https://openrouter.ai/api/v1';

    if (!$apiKey) {
        if (ob_get_length())
            ob_end_clean();
        header('Content-Type: application/json; charset=utf-8');
        echo json_encode(['status' => 'error', 'message' => 'API Anahtarı bulunamadı. Lütfen ayarlardan ekleyin.']);
        exit;
    }

    // $input = json_decode(file_get_contents('php://input'), true); // Zaten yukarıda okundu
    $prompt = $jsonInput['prompt'] ?? '';
    $model = $jsonInput['model'] ?? 'google/gemini-2.0-flash-exp:free';
    $files = $jsonInput['files'] ?? [];

    // System Snapshot Oluştur
    function get_system_snapshot($db)
    {
        $snapshot = [];

        try {
            // 1. Genel Ayarlar
            $stmt = $db->query("SELECT `key`, `value` FROM settings WHERE `key` IN ('active_theme', 'site_title')");
            $settings = $stmt->fetchAll(PDO::FETCH_KEY_PAIR);
            $snapshot['site_info'] = [
                'site_name' => $settings['site_title'] ?? 'SpeedPage',
                'active_theme' => $settings['active_theme'] ?? 'default'
            ];

            // 2. Sistem Hataları (Son 5)
            // Schema: id, user_id, action_type, message, old_data, new_data, created_at
            $stmt = $db->query("SELECT id, message, old_data, new_data, created_at FROM logs WHERE action_type = 'system_error' ORDER BY id DESC LIMIT 5");
            $snapshot['recent_errors'] = $stmt->fetchAll(PDO::FETCH_ASSOC);

            // 3. Tema Dosyaları
            $themeDir = ROOT_DIR . 'themes/' . ($snapshot['site_info']['active_theme']) . '/';
            $snapshot['theme_files'] = [];
            if (is_dir($themeDir)) {
                $snapshot['theme_files'] = array_diff(scandir($themeDir), ['.', '..']);
            }

        } catch (Exception $e) {
            $snapshot['error'] = 'Snapshot alınırken hata oluştu: ' . $e->getMessage();
        }

        return json_encode($snapshot, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);
    }

    $sysSnapshot = get_system_snapshot($db);

    // Admin Yardımcısı Sistem Promptu
    $systemPrompt = "Sen SpeedPage Admin Paneli asistanısın. Görevin sistem yöneticisine kodlama, hata ayıklama ve sistem yönetimi konularında yardımcı olmaktır. Türkçe dilinde yanıt ver. \n\n" .
        "KOD DEĞİŞİKLİĞİ FORMATI (ÖNEMLİ):\n" .
        "Eğer bir kod değişikliği öneriyorsan, yanıt formatın şu şekilde OLMALIDIR:\n" .
        "1. Değişikliği açıkla.\n" .
        "2. Ardından şu blok yapısını kullan:\n" .
        "[PATCH: dosya/yolu.php]\n" .
        "[OLD]\n" .
        "(Değişecek eski kodun tam bloğu)\n" .
        "[/OLD]\n" .
        "[NEW]\n" .
        "(Yeni kodun tam bloğu)\n" .
        "[/NEW]\n\n" .
        "Birden fazla dosya veya blok için bu yapıyı tekrar edebilirsin. Normal kod örnekleri için standart markdown kullanmaya devam et.\n\n" .
        "SİSTEM DURUM RAPORU (SNAPSHOT):\n" .
        "```json\n" . $sysSnapshot . "\n```\n\n" .
        "Yukarıdaki sistem bilgilerini dikkate alarak yanıt ver. Kullanıcı bir dosya paylaştıysa analiz et. Hata varsa çözüm öner.";

    $messages = [
        ["role" => "system", "content" => $systemPrompt],
        ["role" => "user", "content" => $prompt]
    ];

    // Dosya okuma fonksiyonu (Satır bazlı veya Özet)
    function read_relevant_code($filePath, $targetLine = null)
    {
        $fullPath = ROOT_DIR . $filePath;
        if (!file_exists($fullPath))
            return "--- Dosya: $filePath (Bulunamadı) ---";

        $fileSize = filesize($fullPath);

        // 1. Hedef Satır Varsa (Log Hata Analizi)
        if ($targetLine !== null) {
            $lines = file($fullPath);
            $totalLines = count($lines);
            $targetLine = (int) $targetLine;

            $targetIndex = $targetLine - 1;

            $start = max(0, $targetIndex - 30);
            $end = min($totalLines, $targetIndex + 30);
            $length = $end - $start;

            $slice = array_slice($lines, $start, $length);

            $contentWithLines = "";
            foreach ($slice as $i => $line) {
                // Her satırı UTF-8'e zorla (Encoding fix)
                // mb_convert_encoding yerine iconv veya basit bir replace deneyebiliriz ama
                // burada sadece okunan satırı olduğu gibi verelim, json_encode PARTIAL flag'i halletsin.
                $contentWithLines .= ($start + $i + 1) . ": " . $line;
            }

            return "\n\n--- Dosya: $filePath (Satır $start - $end Odaklı) ---\n" . $contentWithLines;
        }

        // 2. Büyük Dosya (>15KB) - Yapısal Özet (Outline)
        if ($fileSize > 15 * 1024) {
            $content = file_get_contents($fullPath);
            // Karakter bozukluğu riskine karşı flag ile okuyamayız ama json_encode halleder.

            // Sadece fonksiyon ve sınıf tanımlarını yakala
            preg_match_all('/^\s*(?:abstract\s+|final\s+|public\s+|protected\s+|private\s+|static\s+)*(?:class|function|interface|trait)\s+[\w]+.*$/m', $content, $matches);

            $structure = implode("\n", $matches[0]);

            // Dosyanın başından biraz al (Imports, defines vb.)
            $head = substr($content, 0, 1000);

            return "\n\n--- Dosya: $filePath (Özet Görünüm - Büyük Dosya) ---\n" .
                "NOT: Dosya boyutu büyük olduğu için sadece yapısal özet ve başlangıç kısmı alındı.\n" .
                "Tam içeriği görmek isterseniz belirtin.\n\n" .
                $head . "\n\n... [İÇERİK GİZLENDİ] ...\n\n" .
                "--- YAPI ÖZETİ ---\n" . $structure;
        }

        // 3. Normal Okuma
        return "\n\n--- Dosya: $filePath ---\n" . file_get_contents($fullPath);
    }

    // ... (Dosya hazırlama döngüleri aynı kalacak, sadece read_relevant_code tanımını güncelledik) ...

    // Dosyaları Hazırla: [Path => LineNumber]
    $finalFilesToRead = [];

    // 1. Kullanıcının seçtiği dosyaları analiz et
    $selectedFiles = [];
    if (!empty($files)) {
        $mentionedFiles = [];
        foreach ($files as $file) {
            $baseName = basename($file);
            if (stripos($prompt, $baseName) !== false) {
                $mentionedFiles[] = $file;
            }
        }
        if (count($mentionedFiles) > 0) {
            $selectedFiles = $mentionedFiles;
        } else {
            $selectedFiles = $files;
        }
    }

    // 3a. Manuel Seçilenler
    if (!empty($selectedFiles)) {
        foreach (array_unique($selectedFiles) as $f) {
            $finalFilesToRead[$f] = null;
        }
    }

    // 2. Loglardan Otomatik Dosya Yakalama
    $errorKeywords = ['hata', 'error', 'bug', 'fix', 'sorun', 'çalışmıyor', 'patladı'];
    $isErrorRelated = false;
    foreach ($errorKeywords as $kw) {
        if (stripos($prompt, $kw) !== false) {
            $isErrorRelated = true;
            break;
        }
    }

    if ($isErrorRelated && isset($sysSnapshot)) {
        $snapshotObj = json_decode($sysSnapshot, true);
        if (!empty($snapshotObj['recent_errors'])) {
            foreach ($snapshotObj['recent_errors'] as $err) {
                // old_data ve new_data sütunlarını birleştirip ara
                $searchContent = ($err['message'] ?? '') . ' ' . ($err['old_data'] ?? '') . ' ' . ($err['new_data'] ?? '');

                preg_match_all('/([a-zA-Z0-9_\-\/\\\\]+\.(php|js|css|sql)).*?(?:line|satır)[:\s]*(\d+)?/i', $searchContent, $matches, PREG_SET_ORDER);

                foreach ($matches as $m) {
                    $foundPath = $m[1];
                    $lineNum = $m[3] ?? null;

                    $cleanPath = str_replace(['\\', '/'], DIRECTORY_SEPARATOR, $foundPath);
                    $rootDirClean = str_replace(['\\', '/'], DIRECTORY_SEPARATOR, ROOT_DIR);

                    if (strpos($cleanPath, $rootDirClean) !== false) {
                        $relPath = str_replace($rootDirClean, '', $cleanPath);
                        $relPath = ltrim(str_replace('\\', '/', $relPath), '/');
                        $finalFilesToRead[$relPath] = $lineNum;
                    }
                }
            }
        }
    }

    // 4. Son Okuma Döngüsü
    foreach ($finalFilesToRead as $filePath => $lineNum) {
        $messages[1]['content'] .= read_relevant_code($filePath, $lineNum);
    }


    $payload = [
        "model" => $model,
        "messages" => $messages,
        "temperature" => 0.7,
        "max_tokens" => 4000,
    ];

    // API URL Hazırla
    $fullApiUrl = rtrim($baseUrl, '/') . '/chat/completions';

    $ch = curl_init($fullApiUrl);
    curl_setopt_array($ch, [
        CURLOPT_HTTPHEADER => [
            "Content-Type: application/json",
            "Authorization: Bearer " . $apiKey,
            "HTTP-Referer: SpeedPageAdmin",
            "X-Title: SpeedPage Admin Panel"
        ],
        CURLOPT_POSTFIELDS => json_encode($payload),
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_TIMEOUT => 120,
        CURLOPT_SSL_VERIFYPEER => false
    ]);

    $response = curl_exec($ch);
    $err = curl_error($ch);
    curl_close($ch);

    if ($err) {
        if (ob_get_length())
            ob_end_clean();
        header('Content-Type: application/json; charset=utf-8');
        echo json_encode(['status' => 'error', 'message' => "CURL Hatası: $err"]);
        exit;
    }

    $data = json_decode($response, true);

    if (isset($data['error'])) {
        if (ob_get_length())
            ob_end_clean();
        header('Content-Type: application/json; charset=utf-8');
        $msg = $data['error']['message'] ?? 'Bilinmeyen API hatası';
        echo json_encode(['status' => 'error', 'message' => "API Hatası: $msg"]);
        exit;
    }

    $aiResponse = $data['choices'][0]['message']['content'] ?? 'AI yanıt vermedi.';

    // Log kaydet
    $lastId = 0;
    try {
        $logStmt = $db->prepare("INSERT INTO ai_logs (user_id, action_type, prompt, response) VALUES (?, 'chat', ?, ?)");
        $logStmt->execute([$_SESSION['user_id'], $prompt, $aiResponse]);
        $lastId = $db->lastInsertId();
    } catch (Exception $e) {
        if (ob_get_length())
            ob_end_clean();
        header('Content-Type: application/json; charset=utf-8');
        echo json_encode(['status' => 'error', 'message' => 'Veritabanı kayıt hatası: ' . $e->getMessage()]);
        exit;
    }

    // JSON Output - SADECE ID DÖN (Text Fetch için)
    if (ob_get_length())
        ob_end_clean();
    header('Content-Type: application/json; charset=utf-8');

    echo json_encode(['status' => 'success', 'log_id' => $lastId]);
    exit;
}

if ($action === 'get_response_text') {
    // Log ID'ye göre yanıtı RAW TEXT olarak ver (JSON parse sorunlarını aşmak için)
    $logId = $_POST['log_id'] ?? 0;

    if ($logId) {
        $stmt = $db->prepare("SELECT response FROM ai_logs WHERE id = ?");
        $stmt->execute([$logId]);
        $response = $stmt->fetchColumn();

        if ($response !== false) {
            // Buffer temizle
            if (ob_get_length())
                ob_end_clean();
            // Düz metin olarak bas
            header('Content-Type: text/plain; charset=utf-8');
            echo $response;
            exit;
        }
    }

    http_response_code(404);
    echo "Log bulunamadı.";
    exit;
}

if ($action === 'apply_ai_patch') {
    $filePath = $_POST['file_path'] ?? ($jsonInput['file_path'] ?? '');
    $oldCode = $_POST['old_code'] ?? ($jsonInput['old_code'] ?? '');
    $newCode = $_POST['new_code'] ?? ($jsonInput['new_code'] ?? '');

    if (!$filePath || !$newCode) {
        echo json_encode(['status' => 'error', 'message' => 'Eksik parametreler.']);
        exit;
    }

    $fullPath = ROOT_DIR . $filePath;

    // Güvenlik Kontrolü
    if (!file_exists($fullPath)) {
        echo json_encode(['status' => 'error', 'message' => 'Hedef dosya bulunamadı.']);
        exit;
    }

    // Path Traversal Check
    $realPath = realpath($fullPath);
    if ($realPath === false || strpos($realPath, realpath(ROOT_DIR)) !== 0) {
        echo json_encode(['status' => 'error', 'message' => 'Geçersiz dosya yolu.']);
        exit;
    }

    // 1. YEDEKLEME (BACKUP)
    $backupDir = __DIR__ . '/_backups/';
    if (!is_dir($backupDir)) {
        mkdir($backupDir, 0755, true);
        // Güvenlik için index.html atalım
        file_put_contents($backupDir . 'index.html', '');
        file_put_contents($backupDir . '.htaccess', 'Deny from all');
    }

    $backupFile = $backupDir . basename($filePath) . '.bak_' . date('Y-m-d_H-i-s');
    if (!copy($fullPath, $backupFile)) {
        echo json_encode(['status' => 'error', 'message' => 'Yedekleme oluşturulamadı. İşlem iptal edildi.']);
        exit;
    }

    // 2. İÇERİK DEĞİŞTİRME (Search & Replace)
    $currentContent = file_get_contents($fullPath);

    // Satır sonu uyumsuzluklarını gidermek için trim ve normalize işlemleri
    // Hem sunucudaki hem inputtaki satır sonlarını standartlaştırmak gerekebilir ama
    // şimdilik basit trim ve str_replace deneyeceğiz.

    // Eğer old_code boşsa, bu bir "Complete Overwrite" isteği olabilir mi? 
    // Güvenlik için old_code zorunlu kılınmalı veya çok dikkatli olunmalı.
    // Şimdilik sadece replace yapacağız.

    if ($oldCode) {
        // Normalleştirme (CRLF vs LF) - Basit çözüm:
        $normalizedCurrent = str_replace("\r\n", "\n", $currentContent);
        $normalizedOld = str_replace("\r\n", "\n", $oldCode);

        if (strpos($normalizedCurrent, $normalizedOld) === false) {
            // Tam eşleşme bulunamadı, belki whitespace farkıdır.
            // Opsiyonel: Daha esnek bir arama yapılabilir ama şimdilik hata dönelim.
            echo json_encode(['status' => 'error', 'message' => 'Eski kod parçası dosyada bulunamadı! Lütfen dosyanın değişmediğinden emin olun.']);
            exit;
        }

        // Değiştirme
        $finalContent = str_replace($normalizedOld, str_replace("\r\n", "\n", $newCode), $normalizedCurrent);
    } else {
        // Old Code yoksa, tüm dosyanın değişmesi gerektiği algılanırsa:
        // Ancak bu tehlikeli, kullanıcı tüm dosyayı seçmediyse...
        // Varsayılan olarak: Eski sistemdeki gibi çalışsın mı? HAYIR. Hata verelim.
        // echo json_encode(['status' => 'error', 'message' => 'Güvenlik: Değiştirilecek eski kod bloğu belirtilmedi.']);
        // exit;

        // VEYA: Eski davranış (Full Overwrite) - Kullanıcının yaşadığı sorunun kaynağı buydu.
        // O yüzden bunu engelliyoruz. Ancak ilk kurulumda problem olmasın diye kontrol:
        // Eğer file size küçükse belki? Hayır.

        // Fallback: Eğer old_code yoksa, mecburen replacement mode değil overwrite mode çalışır.
        // Ama biz kullanıcının sorununu çözmek istiyoruz.
        $finalContent = $newCode;
        // UYARI: Bu satır eski davranışı korur ama tehlikelidir. 
        // Kullanıcı "komple dosya içerigi silinmemeli" dedi.
        // O yüzden ERROR dönüyoruz.
        echo json_encode(['status' => 'error', 'message' => 'Hata: Değiştirilecek "Eski Kod" (Old Code) verisi gelmedi. İşlem durduruldu.']);
        exit;
    }

    // Syntax Check vs... (Zaten aşağıda var)
    // Değişken adı uyumu: $newCode -> $finalContent olarak güncellenmeli veya aşağısı ona göre düzenlenmeli.
    // Aşağıdaki kod $newCode değişkenini kullanıyor. 
    // Biz $finalContent'i $newCode değişkenine atayalım ki akış bozulmasın.
    $newCode = $finalContent;

    // 2. SYNTAX KONTROLÜ
    // Kullanıcı talebi üzerine token_get_all kullanıyoruz, ancak bu tam bir syntax check değildir.
    // Daha güvenli olması için php -l (lint) komutunu deneyeceğiz.

    $syntaxError = null;

    // Yöntem A: PHP Lint (Eğer exec aktifse)
    if (function_exists('exec')) {
        $tempFile = tempnam(sys_get_temp_dir(), 'syntax_check_');
        file_put_contents($tempFile, $newCode);
        $output = [];
        $returnVar = 0;
        exec("php -l " . escapeshellarg($tempFile), $output, $returnVar);
        unlink($tempFile);

        if ($returnVar !== 0) {
            $syntaxError = implode("\n", $output);
            // Dosya yolunu gizle
            $syntaxError = str_replace($tempFile, 'New Code', $syntaxError);
        }
    }
    // Yöntem B: Token Kontrolü (Fallback)
    else {
        try {
            $tokens = token_get_all($newCode, TOKEN_PARSE);
            // TOKEN_PARSE bayrağı syntax hatalarında exception fırlatabilir (PHP sürümüne göre değişir)
            // Ancak genellikle token_get_all syntax hatasında hata vermez, sadece token üretir.
            // Basit parantez kontrolü yapılabilir
            $braces = 0;
            foreach ($tokens as $token) {
                if ($token === '{')
                    $braces++;
                if ($token === '}')
                    $braces--;
            }
            if ($braces !== 0) {
                $syntaxError = "Dengesiz süslü parantez (Brace mismatch). Açılan: $braces";
            }
        } catch (ParseError $e) {
            $syntaxError = $e->getMessage();
        }
    }

    if ($syntaxError) {
        echo json_encode(['status' => 'error', 'message' => 'Syntax Hatası Tespit Edildi:', 'details' => $syntaxError]);
        exit;
    }

    // 3. DOSYAYA YAZMA
    if (file_put_contents($fullPath, $newCode) === false) {
        echo json_encode(['status' => 'error', 'message' => 'Dosyaya yazarken hata oluştu.']);
        exit;
    }

    // 4. LOGLAMA
    $logStmt = $db->prepare("INSERT INTO logs (action_type, message, new_data, user_id) VALUES (?, ?, ?, ?)");
    $logStmt->execute([
        'ai_fix_applied',
        "AI tarafından kod düzeltmesi uygulandı: $filePath",
        json_encode(['backup' => basename($backupFile)]),
        $_SESSION['user_id']
    ]);

    // 5. CACHE / VERSIONING (SPA Entegrasyonu)
    // page_assets tablosunda sürüm güncelle
    try {
        if ($is_sqlite) {
            $db->prepare("INSERT INTO page_assets (file_path, version, updated_at) VALUES (?, 1, CURRENT_TIMESTAMP) 
                           ON CONFLICT(file_path) DO UPDATE SET version = version + 1, updated_at = CURRENT_TIMESTAMP")
                ->execute([$filePath]);
        } else {
            $db->prepare("INSERT INTO page_assets (file_path, version, updated_at) VALUES (?, 1, NOW()) 
                           ON DUPLICATE KEY UPDATE version = version + 1, updated_at = NOW()")
                ->execute([$filePath]);
        }
    } catch (Exception $e) {
        // Tablo yoksa oluşturup tekrar dene (Lazy Creation)
        try {
            if ($is_sqlite) {
                $db->exec("CREATE TABLE IF NOT EXISTS page_assets (file_path TEXT PRIMARY KEY, version INTEGER DEFAULT 1, updated_at DATETIME)");
            } else {
                $db->exec("CREATE TABLE IF NOT EXISTS page_assets (file_path VARCHAR(255) PRIMARY KEY, version INT DEFAULT 1, updated_at DATETIME) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4");
            }
            // Tekrar dene
            if ($is_sqlite) {
                $db->prepare("INSERT INTO page_assets (file_path, version, updated_at) VALUES (?, 1, CURRENT_TIMESTAMP) 
                               ON CONFLICT(file_path) DO UPDATE SET version = version + 1, updated_at = CURRENT_TIMESTAMP")
                    ->execute([$filePath]);
            } else {
                $db->prepare("INSERT INTO page_assets (file_path, version, updated_at) VALUES (?, 1, NOW()) 
                               ON DUPLICATE KEY UPDATE version = version + 1, updated_at = NOW()")
                    ->execute([$filePath]);
            }
        } catch (Exception $ex) {
            // Sessizce geç, kritik değil
        }
    }

    // Bakım işlemlerini çalıştır (Log ve Yedek temizliği)
    speedpage_maintenance($db);

    echo json_encode(['status' => 'success', 'message' => 'Değişiklik başarıyla uygulandı.', 'backup_path' => $backupFile]);
    exit;
}

if ($action === 'list_files') {
    // Güvenli dosya listeleme (Sadece izin verilen uzantılar)
    function getDirContents($dir, &$results = [])
    {
        $allowedExts = ['php', 'js', 'css', 'sql', 'html', 'json']; // İzin verilenler

        $files = scandir($dir);
        foreach ($files as $key => $value) {
            $path = realpath($dir . DIRECTORY_SEPARATOR . $value);
            if (!is_dir($path)) {
                $ext = pathinfo($path, PATHINFO_EXTENSION);
                if (in_array($ext, $allowedExts)) {
                    $relPath = str_replace(realpath(ROOT_DIR), '', $path);
                    $relPath = ltrim(str_replace('\\', '/', $relPath), '/');
                    $results[] = $relPath;
                }
            } else if ($value != "." && $value != ".." && $value != ".git" && $value != "node_modules" && $value != ".vscode") {
                getDirContents($path, $results);
            }
        }
        return $results;
    }

    $fileList = getDirContents(ROOT_DIR);
    echo json_encode(['status' => 'success', 'files' => $fileList]);
    exit;
}

/**
 * Sistem Bakım Fonksiyonu
 * Logları ve eski yedekleri temizler.
 */
function speedpage_maintenance($db)
{
    // 1. Log Temizliği (Son 100 kayıt kalsın)
    // ai_logs tablosundaki timestamp kolonuna göre sıralıyoruz
    try {
        $db->exec("DELETE FROM ai_logs WHERE id NOT IN (
            SELECT id FROM (
                SELECT id FROM ai_logs ORDER BY timestamp DESC LIMIT 100
            ) as t
        )");
    } catch (Exception $e) {
        // Hata durumunda sessiz kal (örn: tablo yoksa)
    }

    // 2. Yedek Temizliği (7 günden eskiler)
    $backupDir = __DIR__ . '/_backups/';
    if (is_dir($backupDir)) {
        $files = scandir($backupDir);
        $now = time();
        foreach ($files as $file) {
            $filePath = $backupDir . $file;
            // .bak_ içeren dosyaları temizle
            if (is_file($filePath) && strpos($file, '.bak_') !== false) {
                if ($now - filemtime($filePath) >= 604800) { // 7 gün
                    unlink($filePath);
                }
            }
        }
    }
}
?>
```